### Technical Design: Fuzzy Search in Superset Table Charts

#### Overview
The goal is to enhance Superset’s Table chart so users can quickly search large tabular datasets with fuzzy matching, typo-tolerance, and clear visual feedback. The solution stays entirely in the frontend for this exercise (Option A), using the existing Table chart plugin and React-table infrastructure, and does not require backend schema changes or new APIs. The same UX should work both for client-side pagination and for server-side pagination, where the backend already limits and sorts results.

#### Architecture Placement
The Table chart is implemented in the `plugin-chart-table` package. Rendering and interaction live primarily in `TableChart.tsx` and its reusable `DataTable` component in `DataTable.tsx`. Global search is powered by React-table’s `useGlobalFilter` hook, which we extend to use a fuzzy-search engine instead of a simple substring match. Search controls and the table body are already wired through the chart’s transformed props, so we augment these components rather than touching Superset’s core explore UI or backend APIs.

#### Fuzzy Search Implementation
For fuzzy matching we use Fuse.js, which is already a dependency of the Superset frontend. In `DataTable.tsx`, the `defaultGlobalFilter` (React-table’s global filter function) is replaced so that, when a non-empty query is provided, it instantiates a Fuse instance over the current set of `Row<D>` objects. The configured keys are `values.<columnId>` for each visible column id, allowing the search to span all displayed columns. We use a `threshold` of 0.4, `ignoreLocation: true`, and `minMatchCharLength: 2` to support partial matches, case-insensitive search, and small typos while avoiding overly noisy results. The filter returns the ordered list of matching rows from Fuse, preserving relevance ordering. For server-side pagination, the chart already uses `manualSearch` and forwards the query to the backend via `setDataMask`, so the Fuse-based global filter is effectively bypassed and does not interfere with backend-driven search.

#### Highlighting and UX
To provide result highlighting, we capture the active search text from React-table via `onFilteredDataChange` in `TableChart.tsx`, and for server-side pagination we additionally read `serverPaginationData.searchText`. Each cell renderer in `TableChart` uses this `searchText` to wrap the first case-insensitive occurrence of the query inside the formatted cell text with a `<mark>` element, while respecting HTML-rendered cells (which continue to use `dangerouslySetInnerHTML` unchanged). Search input remains debounced (800 ms) for server-side search through the existing lodash `debounce` mechanism. Because Fuse.js operates in-memory over the current page of rows, performance is acceptable for at least ~1,000 rows (and typically far more for modern browsers), especially since we rely on the existing virtualized/ paginated table rendering.

#### Potential Challenges and Extensions
Key challenges include balancing fuzziness with result precision (tunable via Fuse’s `threshold` and other options) and making sure client-side search does not conflict with server-side filtering. For production use on very large datasets, a backend approach using PostgreSQL full-text search or Elasticsearch would be preferable, with the frontend acting primarily as a query param builder. Future improvements could include per-column fuzzy search, exposing a “search mode” toggle (exact vs fuzzy), surfacing match context in tooltips, and aligning the highlighting logic more closely with Fuse’s match indices for multi-region highlights.
